# TC-ASM Documentation

## Mnemonics

| Mnemonic  | Expands To                                                 | Description                                                  | Flags Changed (Y/N) | Registers Clobbered | Special Notes                                                                        |
| --------- | ---------------------------------------------------------- | ------------------------------------------------------------ | ------------------- | ------------------- | ------------------------------------------------------------------------------------ |
| `add`     | ``0b00000 @ rD`3 @ rS`3 @ 0b00000 @ 0b00000000``           | `rD ← rD + rS`                                               | Y                   | `rD`                | —                                                                                    |
| `sub`     | ``0b00001 @ rD`3 @ rS`3 @ 0b00000 @ 0b00000000``           | `rD ← rD - rS`                                               | Y                   | `rD`                | —                                                                                    |
| `shl`     | ``0b00010 @ rD`3 @ 0b000 @ 0b00000 @ 0b00000000``          | `rD ← rD << SHIFT_AMT`                                       | Y                   | `rD`                | the SHIFT_AMT register must be set before this is called                             |
| `shr`     | ``0b00011 @ rD`3 @ 0b000 @ 0b00000 @ 0b00000000``          | `rD ← rD >> SHIFT_AMT`                                       | Y                   | `rD`                | the SHIFT_AMT register must be set before this is called                             |
| `and`     | ``0b00100 @ rD`3 @ rS`3 @ 0b00000 @ 0b00000000``           | `rD ← rD AND rS`                                             | Y                   | `rD`                | —                                                                                    |
| `or`      | ``0b00101 @ rD`3 @ rS`3 @ 0b00000 @ 0b00000000``           | `rD ← rD OR rS`                                              | Y                   | `rD`                | —                                                                                    |
| `xor`     | ``0b00110 @ rD`3 @ rS`3 @ 0b00000 @ 0b00000000``           | `rD ← rD XOR rS`                                             | Y                   | `rD`                | —                                                                                    |
| `intret`  | `0b00111 @ 0b000 @ 0b000 @ 0b00000 @ 0b00000000`           | return from interrupt                                        | N                   | —                   | this is unused                                                                       |
| `mov`     | ``0b01000 @ rD`3 @ rS`3 @ 0b00000 @ 0b00000000``           | `rD ← rS`                                                    | N                   | `rD`                | —                                                                                    |
| `ldi`     | ``0b01001 @ rD`3 @ 0b000 @ 0b00000 @ imm8`8``              | `rD ← imm8`                                                  | N                   | `rD`                | 8-bit immediate value                                                                |
| `nop`     | `0b01010 @ 0b000 @ 0b000 @ 0b00000 @ 0b00000000`           | no operation                                                 | N                   | —                   | —                                                                                    |
| `rar`     | ``0b01011 @ rD`3 @ addr_special`3 @ 0b00000 @ 0b00000000`` | read from address register into `rD`                         | N                   | `rD`                | —                                                                                    |
| `adc`     | ``0b01100 @ rD`3 @ rS`3 @ 0b00000 @ 0b00000000``           | `rD ← rD + rS + CARRY`                                       | Y                   | `rD`                | uses carry flag as input                                                             |
| `sbc`     | ``0b01101 @ rD`3 @ rS`3 @ 0b00000 @ 0b00000000``           | `rD ← rD - rS - NOT CARRY`                                   | Y                   | `rD`                | borrow = NOT carry                                                                   |
| `rsr`     | ``0b01110 @ rD`3 @ special_src`3 @ 0b00000 @ 0b00000000``  | read special reg into main reg: `rD ← SPECIAL[special_src]`  | N                   | `rD`                | —                                                                                    |
| `wsr`     | ``0b01111 @ special_dst`3 @ rS`3 @ 0b00000 @ 0b00000000``  | write main reg into special reg: `SPECIAL[special_dst] ← rS` | N                   | `special_dst`       | —                                                                                    |
| `halt`    | `0b10000 @ 0b000 @ 0b000 @ 0b00000 @ 0b00000000`           | halt CPU execution                                           | N                   | —                   | stops execution, cannot be resumed, clock continues                                  |
| `joci`    | ``0b10001 @ 0b0 @ 0b000 @ 0b0 @ cond`4 @ imm10`10``        | conditional absolute jump to immediate address               | N                   | —                   | 10-bit immediate value                                                               |
| `jocr`    | ``0b10001 @ 0b1 @ rA`3 @ 0b0 @ cond`4 @ 0...``             | conditional absolute jump to address in register             | N                   | —                   | register form (`rA`)                                                                 |
| `jroci`   | ``0b10010 @ 0b0 @ 0b000 @ 0b0 @ cond`4 @ imm10`10``        | conditional relative jump by immediate offset                | N                   | —                   | 10-bit immediate value                                                               |
| `jrocr`   | ``0b10010 @ 0b1 @ rA`3 @ 0b0 @ cond`4 @ 0...``             | conditional relative jump by register offset                 | N                   | —                   | relative + register form                                                             |
| `cmp`     | ``0b10011 @ rA`3 @ rB`3 @ 0b00000 @ 0b00000000``           | compare `rA` vs `rB` (sets flags based on `rA - rB`)         | Y                   | —                   | does not write anywhere                                                              |
| `ld`      | ``0b10100 @ rD`3 @ 0b000000 @ imm10_addr`10``              | `rD ← MEM[imm10_addr]`                                       | N                   | `rD`                | absolute memory address is 10-bit immediate                                          |
| `st`      | ``0b10101 @ 0b000 @ rS`3 @ 0b000 @ imm10_addr`10``         | `MEM[imm10_addr] ← rS`                                       | N                   | —                   | absolute memory address is 10-bit immediate                                          |
| `ldr`     | ``0b10110 @ rD`3 @ rAddr`3 @ 0...``                        | `rD ← MEM[rAddr]`                                            | N                   | `rD`                | address comes from register                                                          |
| `str`     | ``0b10111 @ rS`3 @ rAddr`3 @ 0...``                        | `MEM[rAddr] ← rS`                                            | N                   | —                   | address comes from register                                                          |
| `isp`     | `0b11000 @ 0b000000000 @ 0b1111000000`                     | initialize stack pointer                                     | N                   | —                   | only the kernel should use this                                                      |
| `push`    | ``0b11001 @ 0b000 @ rS`3 @ 0...``                          | push `rS` to stack                                           | N                   | SP                  | —                                                                                    |
| `pop`     | ``0b11010 @ rD`3 @ 0b000 @ 0...``                          | pop stack into `rD`                                          | N                   | `rD`, SP            | —                                                                                    |
| `call`    | ``0b11011 @ 0b000 @ 0b000 @ 0b000 @ imm10_addr`10``        | call absolute immediate address                              | N                   | CSP                 | —                                                                                    |
| `callr`   | ``0b11011 @ 0b000 @ rAddr`3 @ 0b100 @ 0...``               | call address in register                                     | N                   | CSP                 | —                                                                                    |
| `ret`     | `0b11100 @ 0b000 @ 0b000 @ 0b000 @ 0...`                   | return from call                                             | N                   | PC, CSP             | —                                                                                    |
| `cim`     | ``0b11101 @ 0b000 @ 0b000 @ 0b00000 @ imm8`8``             | change instruction mode                                      | N                   | —                   | only the kernel should use this; 8-bit immediate but it is onlv valid if it's 0 or 1 |
| `syscall` | `0b11110 @ 0b000 @ 0b000 @ 0b00000 @ 0b00000000`           | enter syscall handler                                        | N                   | `r0`-`r3` at risk   | it may use anything in `r0`-`r3` depending on which kernel function is called        |
| `sysret`  | `0b11111 @ 0b000 @ 0b000 @ 0b00000 @ 0b00000000`           | return from syscall                                          | N                   | `r0`-`r1` at risk   | returns to user; returned values are in r0, errors, if any, will be in r1            |

## Aliases

| Alias  | Expands To           | Description               | Registers Clobbered | Special Notes                                        |
| ------ | -------------------- | ------------------------- | ------------------- | ---------------------------------------------------- |
| `jz`   | `joci ze [{imm10}]`  | jump if zero flag set     | —                   | absolute immediate jump; condition code `ze`         |
| `jnz`  | `joci nze [{imm10}]` | jump if zero flag NOT set | —                   | absolute immediate jump; condition code `nze`        |
| `jmp`  | `joci un [{imm10}]`  | unconditional jump        | —                   | absolute immediate jump; condition code `un`         |
| `juge` | `joci uge [{imm10}]` | jump if unsigned ≥        | —                   | —                                                    |
| `jult` | `joci ult [{imm10}]` | jump if unsigned <        | —                   | —                                                    |
| `jc`   | `joci uge [{imm10}]` | jump if carry set         | —                   | alias of `uge`; carry flag corresponds to unsigned ≥ |


## Macros

| Macro                          | Expands To                                                                                                       | Description                                        | Registers Clobbered  | Privilege (K/U) | Special Notes                                               |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------- | -------------------------------------------------- | -------------------- | --------------- | ----------------------------------------------------------- |
| `%__krnl_getc`                 | `ld r0, [IO_KBD_GETC]`                                                                                           | read character from keyboard MMIO into `r0`        | `r0`                 | K               | kernel-level direct MMIO access                             |
| `%__krnl_putc`                 | `pop r0`<br>`st [IO_TERM_PUTC], r0`                                                                              | pop value and write to terminal MMIO               | `r0`, SP             | K               | consumes stack top                                          |
| `%std_store`                   | `ldi r1, hi2`<br>`push r1`<br>`ldi r1, lo8`<br>`push r1`<br>`ldi r1, value`<br>`push r1`<br>`syscall SYS_STORE8` | store 8-bit value at 10-bit address via syscall    | `r1`, SP             | U               | explicitly clobbers `r1`; uses syscall interface            |
| `%printc`                      | `ldi rX, char`<br>`push rX`<br>`syscall SYS_PUTC`                                                                | print character via syscall                        | specified `rX`, SP   | U               | uses user-level syscall; reg chosen by caller               |
| `%deref_arg`                   | `ldi r3, T_ARGP_n - 0x200`<br>`ldi r1, 0b10`<br>`push r1`<br>`push r3`<br>`syscall SYS_LOAD8`                    | dereference argument pointer (load string pointer) | `r0`, `r1`, `r3`, SP | U               | returns lo8 in `r0`; assumes hi2 = `0b10`; uses `SYS_LOAD8` |
| `%deref_argp_hi2`              | `ldi r3, 0b10`<br>`push r3`<br>`ldi r3, T_ARGP_HI2 - 0x200`<br>`push r3`<br>`syscall SYS_LOAD8`                  | load high 2 bits of argument pointer               | `r3`, SP             | U               | assumes arg memory lives in `0x2XX`                         |
| `%__krnl_printc`               | `ldi rX, char`<br>`st [IO_TERM_PUTC], rX`                                                                        | kernel-mode direct terminal output                 | specified `rX`       | K               | bypasses syscall layer                                      |
| `%__krnl_store`                | `ldi rX, value`<br>`st [address], rX`                                                                            | kernel-mode direct memory store                    | specified `rX`       | K               | bypasses syscall layer                                      |
| `!___INSTRUCTION_MODE`         | `cim imode`                                                                                                      | change CPU instruction mode                        | —                    | K               | immediate must be `0` or `1`; privileged use                |
| `!___INITIALIZE_STACK_POINTER` | `isp`                                                                                                            | initialize stack pointer                           | —                    | K               | privileged; sets initial SP                                 |
| `!___COPY_MODE`                | `ldi r0, params`<br>`wsr COPY_MODE, r0`                                                                          | set COPY_MODE special register via immediate       | `r0`                 | K               | writes to special register `COPY_MODE`                      |
| `!___COPY_MODE_REG`            | `wsr COPY_MODE, rN`                                                                                              | set COPY_MODE from register                        | —                    | K               | writes special register directly                            |



